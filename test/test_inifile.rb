# Code Generated by ZenTest v. 3.3.0
#                 classname: asrt / meth =  ratio%
#             Rini::IniFile:    0 /    9 =   0.00%

# encoding: UTF-8

# Add this libdir to loadpath
#$:.push File.expand_path("../../lib", __FILE__)

begin
  require 'inifile'
rescue LoadError
  require 'rubygems'
  require 'inifile'
end

require 'fileutils'

begin; require 'turn'; rescue LoadError; end
require 'test/unit' unless defined? $ZENTEST and $ZENTEST

class TestIniFile < Test::Unit::TestCase

  def setup
    @ini_file = IniFile.new 'test/data/good.ini'
    @contents = [
      ['section_one', 'one', '1'],
      ['section_one', 'two', '2'],
      ['section_two', 'three', '3'],
      ['section_two', 'multi', "multiline\nsupport"],
      ['section three', 'four', '4'],
      ['section three', 'five', '5'],
      ['section three', 'six', '6'],
      ['section_five', 'seven and eight', '7 & 8']
    ].sort

    FileUtils.rm_rf "test/data/tmp.ini"
    FileUtils.cp    "test/data/good.ini", "test/data/tmp.ini"
  end

  def teardown
    FileUtils.rm_rf "test/data/tmp.ini"
  end

  def test_class_load
    ini_file = IniFile.load 'test/data/good.ini'
    assert_instance_of IniFile, ini_file

    # see if we can parse different style comments
    assert_raise(IniFile::Error) {IniFile.load 'test/data/comment.ini', :comment => ';'}

    ini_file = IniFile.load 'test/data/comment.ini', :comment => '#'
    assert_instance_of IniFile, ini_file

    # see if we can parse mixed style comments
    assert_raise(IniFile::Error) {IniFile.load 'test/data/mixed_comment.ini', :comment => '#'}

    ini_file = IniFile.load 'test/data/mixed_comment.ini', :comment => ';#'
    assert_instance_of IniFile, ini_file

    # see if we can parse different style param separators
    assert_raise(IniFile::Error) {IniFile.load 'test/data/param.ini'}

    ini_file = IniFile.load 'test/data/param.ini', :parameter => ':'
    assert_instance_of IniFile, ini_file

    # make sure we error out on files with bad lines
    assert_raise(IniFile::Error) {IniFile.load 'test/data/bad_1.ini'}
    assert_raise(IniFile::Error) {IniFile.load 'test/data/bad_2.ini'}
  end

  def test_clone
    clone = @ini_file.clone
    assert_equal @ini_file, clone
    assert !clone.tainted?
    assert !clone.frozen?

    # the clone should be completely independent of the original
    clone['new_section']['one'] = 1
    assert_not_equal @ini_file, clone

    # the tainted state is copied to clones
    @ini_file.taint
    assert @ini_file.tainted?

    clone = @ini_file.clone
    assert clone.tainted?

    # the frozen state is also copied to clones
    @ini_file.freeze
    assert @ini_file.frozen?

    clone = @ini_file.clone
    assert clone.tainted?
    assert clone.frozen?
  end

  def test_delete_section
    assert_nil @ini_file.delete_section('section_nil')

    h = {'one' => '1', 'two' => '2'}
    assert_equal true, @ini_file.has_section?('section_one')
    assert_equal h, @ini_file.delete_section('section_one')
    assert_equal false, @ini_file.has_section?('section_one')
    assert_nil @ini_file.delete_section('section_one')
  end

  def test_dup
    dup = @ini_file.dup
    assert_equal @ini_file, dup
    assert !dup.tainted?
    assert !dup.frozen?

    # the duplicate should be completely independent of the original
    dup['new_section']['one'] = 1
    assert_not_equal @ini_file, dup

    # the tainted state is copied to duplicates
    @ini_file.taint
    assert @ini_file.tainted?

    dup = @ini_file.dup
    assert dup.tainted?

    # the frozen state, however, is not
    @ini_file.freeze
    assert @ini_file.frozen?

    dup = @ini_file.dup
    assert dup.tainted?
    assert !dup.frozen?
  end

  def test_each
    ary = []
    @ini_file.each {|*args| ary << args}

    assert_equal @contents, ary.sort

    ary = []
    IniFile.new('temp.ini').each {|*args| ary << args}
    assert_equal [], ary
  end

  def test_each_section
    expected = [
      'section_one', 'section_two', 'section three',
      'section_four', 'section_five'
    ].sort

    ary = []
    @ini_file.each_section {|section| ary << section}

    assert_equal expected, ary.sort

    ary = []
    IniFile.new('temp.ini').each_section {|section| ary << section}
    assert_equal [], ary
  end

  def test_eql_eh
    assert @ini_file.eql?(@ini_file)
    assert @ini_file.eql?(@ini_file.clone)
    assert !@ini_file.eql?('string')
    assert !@ini_file.eql?(IniFile.new(''))
  end

  def test_freeze
    assert_equal false, @ini_file.frozen?
    @ini_file.each_section do |s|
      assert_equal false, @ini_file[s].frozen?
    end

    @ini_file.freeze

    assert_equal true, @ini_file.frozen?
    @ini_file.each_section do |s|
      assert_equal true, @ini_file[s].frozen?
    end
  end

  def test_has_section_eh
    assert_equal true,  @ini_file.has_section?('section_one')
    assert_equal false, @ini_file.has_section?('section_ten')
    assert_equal true,  @ini_file.has_section?(:section_two)
    assert_equal false, @ini_file.has_section?(nil)

    ini_file = IniFile.new 'temp.ini'
    assert_equal false, ini_file.has_section?('section_one')
    assert_equal false, ini_file.has_section?('one')
    assert_equal false, ini_file.has_section?('two')
  end

  def test_index
    expected = {
      'one' => '1',
      'two' => '2'
    }
    assert_equal expected, @ini_file[:section_one]

    expected = {'three' => '3', 'multi' => "multiline\nsupport"}
    assert_equal expected, @ini_file['section_two']

    expected = {
      'four' => '4',
      'five' => '5',
      'six'  => '6',
    }
    assert_equal expected, @ini_file['section three']

    expected = {}
    assert_equal expected, @ini_file['section_four']

    expected = {'seven and eight' => '7 & 8'}
    assert_equal expected, @ini_file['section_five']

    expected = {}
    assert_equal expected, @ini_file['section_six']

    assert_nil @ini_file[nil]

    expected = {}
    ini_file = IniFile.new 'temp.ini'
    assert_equal expected, ini_file['section_one']
    assert_equal expected, ini_file['one']
    assert_nil ini_file[nil]
  end

  def test_initialize
    # see if we can parse different style comments
    #assert_raise(IniFile::Error) {IniFile.new 'test/data/comment.ini'}

    ini_file = IniFile.new 'test/data/comment.ini', :comment => '#'
    assert_equal true, ini_file.has_section?('section_one')

    # see if we can parse different style param separators
    assert_raise(IniFile::Error) {IniFile.new 'test/data/param.ini'}

    ini_file = IniFile.new 'test/data/param.ini', :parameter => ':'
    assert_equal true, ini_file.has_section?('section_one')
    assert_equal '1', ini_file['section_one']['one']
    assert_equal '2', ini_file['section_one']['two']

    # make sure we error out on files with bad lines
    assert_raise(IniFile::Error) {IniFile.new 'test/data/bad_1.ini'}
    assert_raise(IniFile::Error) {IniFile.new 'test/data/bad_2.ini'}
  end

  def test_sections
    expected = [
      'section_one', 'section_two', 'section three',
      'section_four', 'section_five'
    ].sort

    assert_equal expected, @ini_file.sections.sort

    ini_file = IniFile.new 'temp.ini'
    assert_equal [], ini_file.sections
  end

  def test_taint
    assert_equal false, @ini_file.tainted?
    @ini_file.each_section do |s|
      assert_equal false, @ini_file[s].tainted?
    end

    @ini_file.taint

    assert_equal true, @ini_file.tainted?
    @ini_file.each_section do |s|
      assert_equal true, @ini_file[s].tainted?
    end
  end

  def test_write
    tmp = 'test/data/temp.ini'
    File.delete tmp if Kernel.test(?f, tmp)

    @ini_file.save tmp
    assert_equal true, Kernel.test(?f, tmp)

    File.delete tmp if Kernel.test(?f, tmp)

    ini_file = IniFile.new tmp
    ini_file.save
    assert_nil Kernel.test(?s, tmp)

    File.delete tmp if Kernel.test(?f, tmp)
  end

  def test_modifies_current_keys
    ini = IniFile.load("test/data/tmp.ini")
    ini["section one"]["one"] = 17
    ini.save

    assert File.read("test/data/tmp.ini") =~ /one = 17/
  end

  def test_can_add_key_to_inifile
    ini_file = IniFile.new("test/data/tmp.ini")
    ini_file["new_section"] = {}
    ini_file.save

    assert File.read("test/data/tmp.ini") =~ /\[new_section\]/
  end

  def test_adds_correct_key_to_inifile
    ini_file = IniFile.new("test/data/tmp.ini")
    ini_file["foo"] = {}
    ini_file.save

    assert File.read("test/data/tmp.ini") =~ /\[foo\]/
  end

  def test_assigns_values_to_inifile
    ini_file = IniFile.new("test/data/tmp.ini")
    ini_file["foo"] = {
      :bar => "baz"
    }

    assert_equal ini_file["foo"], { :bar => "baz" }
  end

  def test_assigns_correct_values_to_inifile
    ini_file = IniFile.new("test/data/tmp.ini")
    ini_file["foo"] = {
      :one => "two"
    }

    assert_equal ini_file["foo"], { :one => "two" }
  end

  def test_assignment_stringifies_key
    ini_file = IniFile.new("test/data/tmp.ini")
    ini_file["foo"] = {:one => :two}
    ini_file[:foo] = {}
    assert_equal ini_file["foo"], {}
  end

  def test_multiline_parsing
    ini_file = IniFile.load('test/data/multiline.ini')

    multiline = ini_file['section_three']
    expected = {"three" => "hello\nmultiline", "other" => "stuff"}
    assert_equal expected, multiline

    multiple = ini_file['section_four']
    expected = {"four" => "hello\nmultiple\nmultilines"}
    assert_equal expected, multiple

    multiple = ini_file['empty_lines']
    expected = {'empty' => '', 'not_empty' => 'full'}

  end
  
  def test_merge
    ini_file = @ini_file.merge(IniFile.load("test/data/merge.ini"))
    assert_equal '3', ini_file['section_one']['one']
    assert_equal '2', ini_file['section_one']['two']
    # Make sure that the rest haven't changed
    assert_equal '3', ini_file['section_two']['three']
    # And that we got any additional sections too
    assert_equal '5', ini_file['section_five']['five']
  end

  if RUBY_VERSION >= '1.9'
    def test_parse_encoding
      ini_file = IniFile.new("test/data/browscap.ini", :encoding => 'ISO-8859-1')
      assert_equal ini_file['www.substancia.com AutoHTTPAgent (ver *)']['Browser'], "Subst\xE2ncia".force_encoding('ISO-8859-1')
    end

    def test_write_encoding
      tmp = 'test/data/tmp.ini'
      File.delete tmp if Kernel.test(?f, tmp)

      @ini_file = IniFile.new(tmp, :encoding => 'UTF-8')
      @ini_file['testutf-8'] = {"utf-8" => "appr\u20accier"}

      @ini_file.save tmp

      test = File.open(tmp)
      assert_equal test.external_encoding.to_s, 'UTF-8'
    end
  end

end

